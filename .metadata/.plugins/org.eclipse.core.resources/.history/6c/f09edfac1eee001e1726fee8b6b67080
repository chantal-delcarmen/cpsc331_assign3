package bst;

/**
 * 
 * Code reused and modified from tutorial notes 
 */

class Node {
	int value = 0;
	Node left = null;
	Node right = null;
	
	public Node(int value) {
		this.value = value;
	}
}


public class BinarySearchTree<T extends Comparable<T>> {
	Node root = null;
	

	// Check if it exists in tree
	// If does not exist already in tree, 
		// Insert node
	public Node search(Node root, int key) {
		if(root == null || root.value == key) {
			return root;
		}
		
		if (root.value < key) {
			return search(root.right, key);
		}
		
		return search(root.left, key);
	}
	
    public boolean contains(T element) {
        return containsRecursive(root, element);
    }

    private boolean containsRecursive(Node current, T element) {
        if (current == null) {
            return false;
        }

        if (element.compareTo(current.data) == 0) {
            return true;
        }

        return element.compareTo(current.data) < 0
            ? containsRecursive(current.left, element)
            : containsRecursive(current.right, element);
    }
    
	public Node insert(int number) {
		
		
		return root;
	}
	
	// Remove odd value nodes from tree
	
	// Insert k = 50 new random integers 
	// Check if exists in tree
	// If not in tree, repeat the following
	
		// Find height of the tree
	
		// Measure time needed for insertion process
	
		// Store values (hi, ti) in data structure
}
